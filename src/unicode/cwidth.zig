// Port of wcwidth implementation into Zig:
//
// ** Original text: **
//
// This is an implementation of wcwidth() and wcswidth() (defined in
// IEEE Std 1002.1-2001) for Unicode.
//
// http://www.opengroup.org/onlinepubs/007904975/functions/wcwidth.html
// http://www.opengroup.org/onlinepubs/007904975/functions/wcswidth.html
//
// (...)
//
// http://www.unicode.org/unicode/reports/tr11/
//
// Markus Kuhn -- 2007-05-26 (Unicode 5.0)
//
// Permission to use, copy, modify, and distribute this software
// for any purpose and without fee is hereby granted. The author
// disclaims all warranties with regard to this software.
//
// Latest version: http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c

const Interval = [2]u32;

fn bisearch(ucs: u32, table: []const Interval) bool {
    var min: usize = 0;
    var max: usize = table.len - 1;

    if (ucs < table[0][0] or ucs > table[max][1]) {
        return false;
    }

    while (max >= min) {
        const mid = (min + max) / 2;
        if (ucs > table[mid][1]) {
            min = mid + 1;
        } else if (ucs < table[mid][0]) {
            max = mid - 1;
        } else {
            return true;
        }
    }

    return false;
}

const COMBINING = [_]Interval{ [2]u32{ 0x0300, 0x036F }, [2]u32{ 0x0483, 0x0486 }, [2]u32{ 0x0488, 0x0489 }, [2]u32{ 0x0591, 0x05BD }, [2]u32{ 0x05BF, 0x05BF }, [2]u32{ 0x05C1, 0x05C2 }, [2]u32{ 0x05C4, 0x05C5 }, [2]u32{ 0x05C7, 0x05C7 }, [2]u32{ 0x0600, 0x0603 }, [2]u32{ 0x0610, 0x0615 }, [2]u32{ 0x064B, 0x065E }, [2]u32{ 0x0670, 0x0670 }, [2]u32{ 0x06D6, 0x06E4 }, [2]u32{ 0x06E7, 0x06E8 }, [2]u32{ 0x06EA, 0x06ED }, [2]u32{ 0x070F, 0x070F }, [2]u32{ 0x0711, 0x0711 }, [2]u32{ 0x0730, 0x074A }, [2]u32{ 0x07A6, 0x07B0 }, [2]u32{ 0x07EB, 0x07F3 }, [2]u32{ 0x0901, 0x0902 }, [2]u32{ 0x093C, 0x093C }, [2]u32{ 0x0941, 0x0948 }, [2]u32{ 0x094D, 0x094D }, [2]u32{ 0x0951, 0x0954 }, [2]u32{ 0x0962, 0x0963 }, [2]u32{ 0x0981, 0x0981 }, [2]u32{ 0x09BC, 0x09BC }, [2]u32{ 0x09C1, 0x09C4 }, [2]u32{ 0x09CD, 0x09CD }, [2]u32{ 0x09E2, 0x09E3 }, [2]u32{ 0x0A01, 0x0A02 }, [2]u32{ 0x0A3C, 0x0A3C }, [2]u32{ 0x0A41, 0x0A42 }, [2]u32{ 0x0A47, 0x0A48 }, [2]u32{ 0x0A4B, 0x0A4D }, [2]u32{ 0x0A70, 0x0A71 }, [2]u32{ 0x0A81, 0x0A82 }, [2]u32{ 0x0ABC, 0x0ABC }, [2]u32{ 0x0AC1, 0x0AC5 }, [2]u32{ 0x0AC7, 0x0AC8 }, [2]u32{ 0x0ACD, 0x0ACD }, [2]u32{ 0x0AE2, 0x0AE3 }, [2]u32{ 0x0B01, 0x0B01 }, [2]u32{ 0x0B3C, 0x0B3C }, [2]u32{ 0x0B3F, 0x0B3F }, [2]u32{ 0x0B41, 0x0B43 }, [2]u32{ 0x0B4D, 0x0B4D }, [2]u32{ 0x0B56, 0x0B56 }, [2]u32{ 0x0B82, 0x0B82 }, [2]u32{ 0x0BC0, 0x0BC0 }, [2]u32{ 0x0BCD, 0x0BCD }, [2]u32{ 0x0C3E, 0x0C40 }, [2]u32{ 0x0C46, 0x0C48 }, [2]u32{ 0x0C4A, 0x0C4D }, [2]u32{ 0x0C55, 0x0C56 }, [2]u32{ 0x0CBC, 0x0CBC }, [2]u32{ 0x0CBF, 0x0CBF }, [2]u32{ 0x0CC6, 0x0CC6 }, [2]u32{ 0x0CCC, 0x0CCD }, [2]u32{ 0x0CE2, 0x0CE3 }, [2]u32{ 0x0D41, 0x0D43 }, [2]u32{ 0x0D4D, 0x0D4D }, [2]u32{ 0x0DCA, 0x0DCA }, [2]u32{ 0x0DD2, 0x0DD4 }, [2]u32{ 0x0DD6, 0x0DD6 }, [2]u32{ 0x0E31, 0x0E31 }, [2]u32{ 0x0E34, 0x0E3A }, [2]u32{ 0x0E47, 0x0E4E }, [2]u32{ 0x0EB1, 0x0EB1 }, [2]u32{ 0x0EB4, 0x0EB9 }, [2]u32{ 0x0EBB, 0x0EBC }, [2]u32{ 0x0EC8, 0x0ECD }, [2]u32{ 0x0F18, 0x0F19 }, [2]u32{ 0x0F35, 0x0F35 }, [2]u32{ 0x0F37, 0x0F37 }, [2]u32{ 0x0F39, 0x0F39 }, [2]u32{ 0x0F71, 0x0F7E }, [2]u32{ 0x0F80, 0x0F84 }, [2]u32{ 0x0F86, 0x0F87 }, [2]u32{ 0x0F90, 0x0F97 }, [2]u32{ 0x0F99, 0x0FBC }, [2]u32{ 0x0FC6, 0x0FC6 }, [2]u32{ 0x102D, 0x1030 }, [2]u32{ 0x1032, 0x1032 }, [2]u32{ 0x1036, 0x1037 }, [2]u32{ 0x1039, 0x1039 }, [2]u32{ 0x1058, 0x1059 }, [2]u32{ 0x1160, 0x11FF }, [2]u32{ 0x135F, 0x135F }, [2]u32{ 0x1712, 0x1714 }, [2]u32{ 0x1732, 0x1734 }, [2]u32{ 0x1752, 0x1753 }, [2]u32{ 0x1772, 0x1773 }, [2]u32{ 0x17B4, 0x17B5 }, [2]u32{ 0x17B7, 0x17BD }, [2]u32{ 0x17C6, 0x17C6 }, [2]u32{ 0x17C9, 0x17D3 }, [2]u32{ 0x17DD, 0x17DD }, [2]u32{ 0x180B, 0x180D }, [2]u32{ 0x18A9, 0x18A9 }, [2]u32{ 0x1920, 0x1922 }, [2]u32{ 0x1927, 0x1928 }, [2]u32{ 0x1932, 0x1932 }, [2]u32{ 0x1939, 0x193B }, [2]u32{ 0x1A17, 0x1A18 }, [2]u32{ 0x1B00, 0x1B03 }, [2]u32{ 0x1B34, 0x1B34 }, [2]u32{ 0x1B36, 0x1B3A }, [2]u32{ 0x1B3C, 0x1B3C }, [2]u32{ 0x1B42, 0x1B42 }, [2]u32{ 0x1B6B, 0x1B73 }, [2]u32{ 0x1DC0, 0x1DCA }, [2]u32{ 0x1DFE, 0x1DFF }, [2]u32{ 0x200B, 0x200F }, [2]u32{ 0x202A, 0x202E }, [2]u32{ 0x2060, 0x2063 }, [2]u32{ 0x206A, 0x206F }, [2]u32{ 0x20D0, 0x20EF }, [2]u32{ 0x302A, 0x302F }, [2]u32{ 0x3099, 0x309A }, [2]u32{ 0xA806, 0xA806 }, [2]u32{ 0xA80B, 0xA80B }, [2]u32{ 0xA825, 0xA826 }, [2]u32{ 0xFB1E, 0xFB1E }, [2]u32{ 0xFE00, 0xFE0F }, [2]u32{ 0xFE20, 0xFE23 }, [2]u32{ 0xFEFF, 0xFEFF }, [2]u32{ 0xFFF9, 0xFFFB }, [2]u32{ 0x10A01, 0x10A03 }, [2]u32{ 0x10A05, 0x10A06 }, [2]u32{ 0x10A0C, 0x10A0F }, [2]u32{ 0x10A38, 0x10A3A }, [2]u32{ 0x10A3F, 0x10A3F }, [2]u32{ 0x1D167, 0x1D169 }, [2]u32{ 0x1D173, 0x1D182 }, [2]u32{ 0x1D185, 0x1D18B }, [2]u32{ 0x1D1AA, 0x1D1AD }, [2]u32{ 0x1D242, 0x1D244 }, [2]u32{ 0xE0001, 0xE0001 }, [2]u32{ 0xE0020, 0xE007F }, [2]u32{ 0xE0100, 0xE01EF } };

pub fn cwidth(ucs: u32) u3 {
    // test for 8-bit control characters
    if (ucs == 0) {
        return 0;
    }
    if (ucs < 32 or (ucs >= 0x7f and ucs < 0xa0)) {
        return 0;
    }

    // binary search in table of non-spacing characters
    if (bisearch(ucs, &COMBINING)) {
        return 0;
    }

    // if we arrive here, ucs is not a combining or C0/C1 control character

    if (ucs >= 0x1100 and
        (ucs <= 0x115f or // Hangul Jamo init. consonants
        ucs == 0x2329 or ucs == 0x232a or
        (ucs >= 0x2e80 and ucs <= 0xa4cf and
        ucs != 0x303f) or // CJK ... Yi
        (ucs >= 0xac00 and ucs <= 0xd7a3) or // Hangul Syllables
        (ucs >= 0xf900 and ucs <= 0xfaff) or // CJK Compatibility Ideographs
        (ucs >= 0xfe10 and ucs <= 0xfe19) or // Vertical forms
        (ucs >= 0xfe30 and ucs <= 0xfe6f) or // CJK Compatibility Forms
        (ucs >= 0xff00 and ucs <= 0xff60) or // Fullwidth Forms
        (ucs >= 0xffe0 and ucs <= 0xffe6) or
        (ucs >= 0x20000 and ucs <= 0x2fffd) or
        (ucs >= 0x30000 and ucs <= 0x3fffd)))
    {
        return 2;
    }

    return 1;
}
